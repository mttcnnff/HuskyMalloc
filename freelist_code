#include <stdlib.h>
#include <stdio.h>
#include <sys/mman.h>
#include <string.h>
#include "freelist.h"

/*

typedef struct freeblock {
	size_t size;
	struct freeblock* next;
} freeblock;

*/

// size_t 
// memory_getsize(void* memory)
// {
//   return *(size_t*)(memory - sizeof(size_t));
// }

freeblock*
freeblock_make(void* address)
{

	size_t size = *(size_t*)address;
	if (size > sizeof(freeblock)) 
	{
		freeblock* new = (freeblock*)address;
		new->size = size;
		new->next = NULL;
		return new;
	}
	return NULL;
}

void 
freeblock_print(freeblock* block)
{
	if (block) {
		printf("[Address: %p, Size: %zu]\n", block, block->size);
	}
	return;
}

void 
freelist_insert(freeblock** head, void* addition)
{

	freeblock* current = *head;
	freeblock* previous = NULL;
	freeblock* newblock = NULL;

	while (current && (void*)current < addition)
	{
		previous = current;
		current = current->next;
	}

	void* previous_memory_end = previous ? previous + previous->size : NULL;
	void* newblock_memory_begin = addition;
	void* newblock_memory_end = addition + *(size_t*)addition;
	void* current_memory_begin = current ? current : NULL;

	if (previous_memory_end != newblock_memory_begin && newblock_memory_end != current_memory_begin) {
		newblock = freeblock_make(addition);
		if (previous)
		{
			previous->next = newblock;
		} else {
			*head = newblock;
		}
		newblock->next = current;
	} else {
		if (previous_memory_end == newblock_memory_begin) {
			size_t prev_new_size = previous->size + *(size_t*)addition;
			memcpy(previous, &prev_new_size, sizeof(size_t));
			newblock = previous;
		}

		if (newblock_memory_end == current_memory_begin) {
			if (newblock) {
				//expand newblock
				size_t newblock_new_size = newblock->size + current->size;
				memcpy(newblock, &newblock_new_size, sizeof(size_t));
				freelist_remove(head, current);
			} else {
				//expand current backward
				size_t current_new_size = current->size + *(size_t*)addition;
				memcpy(current, &current_new_size, sizeof(size_t));
			}

			
		}

	}
}

freeblock* 
freelist_remove(freeblock** head, freeblock* block)
{
	freeblock* current = *head;
	freeblock* previous = NULL;

	while (current && current != block)
	{
		previous = current;
		current = current->next;
	}

	if (current) {
		if (previous) {
			previous->next = current->next;
		} else {
			//removing head
			*head = current->next;
		}
		current->next = NULL;
		return current;
	} else {
		return NULL;
	}
}

void* 
freelist_getblock(freeblock** head, size_t size) 
{
	freeblock* current = *head;
	while (current && current->size < size) {
		current = current->next;
	}

	if (current) {
		current = freelist_remove(head, current);
		void* memory = (void*)current;
		size_t leftover = current->size - size;
		if (leftover > sizeof(freeblock))
		{
			memcpy(memory + size, &leftover, sizeof(size_t));
			freelist_insert(head, memory + size);
		} 
		memcpy(memory, &size, sizeof(size_t));
		return memory;
	} else {
		return NULL;
	}
}

void
freelist_print(freeblock* head)
{
	int size = freelist_getsize(head);
	printf("Freelist Size: %d\n", size);
	freeblock* current = head;
	while (current) {
		freeblock_print(current);
		current = current->next;
	}
	return;
}

int 
freelist_sorted(freeblock* head)
{
	freeblock* current = head;
	while (current && current->next) {
		if (current > current->next) {
			return 0;
		}
		current = current->next;
	}
	return 1;
}

int 
freelist_getsize(freeblock* head)
{
	int size = 0;
	freeblock* current = head;
	while (current && current->next) {
		current = current->next;
		size++;
	}
	size++;
	return size;
}
